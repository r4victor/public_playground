# Почти-дерево (near-tree)

На вход подается взвешенный связный граф с m <= n+8. Требуется найти минимальный остов данного графа за O(n). 

(Kleinberg, Tardos. Algorithm design chapter 4, exercise 21)

## Решение

В дереве m=n-1, поэтому поданный граф можно рассматривать как дерево в которой добавили не более 9 лишних ребер. Идея алгоритма – удалить эти ребра. Для этого пока в графе есть циклы (m>n-1), нужно находить цикл и удалять из графа самое тяжелое ребро в цикле. Это стратегия работает потому, что самое тяжое ребро из цикла не может входить в минимальный остов.

```text
вход: граф
выход: минимальный остов (как граф)

пока в графе есть циклы:
	цикл = найти_цикл(граф)
	граф = удалить_из_графа_самое_тяжелое_ребро_в_цикле(граф, цикл)
	
вернуть граф
```

## Сложность

Максимальное число итерации цикла – это количество лишних ребер = 9. Цикл находится поиском в глубину за О(m), нахождение самого тяжелого ребра в цикле также О(m). Следовательно, алгоритм работает за O(m)=O(n).

## Доказательство корректности

1. Алгоритм возвращает остов. Так как алгоритм удаляет только ребра из циклов, связность графа не нарушается. Алгоритм останавливается, когда в графе нет циклов. Следовательно, полученный граф – остов.

2. Алгоритм возвращает минимальный остов. Докажем, что после каждого удаления ребра, полученный граф содержит некоторый минимальный остов. Когда циклов не осталось и ребра удалить нельзя, алгоритм возвращает остов, а остов содержащий минимальный остов и является этим минимальным остовом. Из чего будет следовать, что алгоритм возвращает минимальный остов.

   Изначально граф содержит минимальный остов по определению остова. Пусть после удаления некторого количества ребер мы имеем граф G, который содержит некоторый минимальный остов T и G != T (иначе алгоритм возвращает G). Покажем, что после удаления алгоритмом ребра e из G, полученный граф G' содержит минимальный остов T' (необходимо показать что такое T'). Если e не принадлежит T, то T' = T. Рассмотрим случай, когда e принадлежит T. Если удалить e=(u,v) из остова T, то T будет разбит на две компоненты связности U и V. Цикл, из которого алгоритм удалил ребро e, должен содержать ребро t, не принадлежащее остову T и соединяющее вершину из U с вершиной из V. Такое ребро найдется, так как иначе

   1. T содержал бы цикл; или
   2. Цикл бы полностью лежал в одной компоненте U или V.

   Убрав из T ребро e и добавив ребро t, получим остов T' (разрушаем связность и восстанавливаем связность, циклов не появится). Покажем, что T' – минимальный остов. weight(e) >= weight(t) в силу того, что алгоритм выбирает самое тяжелое ребро из цикла. При это не может быть, что weight(e) > weight(t), так как иначе вес T был бы строго больше веса T', и T не был бы минимальным остовом. Таким образом, weight(e) = weight(t), веса остовов T и T' совпадают, и T' – минимальный остов, содержащийся в G'.

   

